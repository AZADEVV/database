postgres=# CREATE TABLE accounts (
postgres(#     account_id SERIAL PRIMARY KEY,
postgres(#     owner_name VARCHAR(100),
postgres(#     balance DECIMAL(10,2)
postgres(# );
CREATE TABLE
postgres=#
postgres=# INSERT INTO accounts (owner_name, balance)
postgres-# VALUES
postgres-# ('Aibek', 1000.00),
postgres-# ('Nursultan', 500.00);
INSERT 0 2
postgres=#
postgres=# BEGIN;
BEGIN
postgres=*# UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE 1
postgres=*# UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;
UPDATE 1
postgres=*# COMMIT; -- Both updates are saved permanently
COMMIT
postgres=#
postgres=#
postgres=# BEGIN;
BEGIN
postgres=*# UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE 1
postgres=*# UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;
UPDATE 1
postgres=*# -- Something went wrong, undo everything
postgres=*# ROLLBACK; -- Both updates are undone
ROLLBACK
postgres=#
postgres=#
postgres=# BEGIN;
BEGIN
postgres=*#
postgres=*# -- Check if account 1 has sufficient balance
postgres=*# SELECT balance FROM accounts WHERE account_id = 1;
 balance
---------
  900.00
(1 row)


postgres=*#
postgres=*# -- If sufficient, perform the transfer
postgres=*# UPDATE accounts SET balance = balance - 500 WHERE account_id = 1;
UPDATE 1
postgres=*# UPDATE accounts SET balance = balance + 500 WHERE account_id = 2;
UPDATE 1
postgres=*#
postgres=*# -- If everything is correct, commit
postgres=*# COMMIT;
COMMIT
postgres=#
postgres=#
postgres=# CREATE TABLE orders (
postgres(#     order_id SERIAL PRIMARY KEY,
postgres(#     customer_id INT,
postgres(#     order_date DATE DEFAULT CURRENT_DATE,
postgres(#     total DECIMAL(10,2)
postgres(# );
CREATE TABLE
postgres=#
postgres=# CREATE TABLE order_items (
postgres(#     item_id SERIAL PRIMARY KEY,
postgres(#     order_id INT REFERENCES orders(order_id),
postgres(#     product_id INT,
postgres(#     quantity INT
postgres(# );
CREATE TABLE
postgres=#
postgres=# CREATE TABLE inventory (
postgres(#     product_id INT PRIMARY KEY,
postgres(#     product_name VARCHAR(100),
postgres(#     stock INT
postgres(# );
CREATE TABLE
postgres=#
postgres=#
postgres=# INSERT INTO inventory (product_id, product_name, stock)
postgres-# VALUES
postgres-# (101, 'Laptop', 10),
postgres-# (102, 'Mouse', 50),
postgres-# (103, 'Keyboard', 25);
INSERT 0 3
postgres=#
postgres=# BEGIN;
BEGIN
postgres=*# INSERT INTO orders (customer_id, total) VALUES (1, 250.00);
INSERT 0 1
postgres=*# INSERT INTO order_items (order_id, product_id, quantity) VALUES (1, 101, 2);
INSERT 0 1
postgres=*# UPDATE inventory SET stock = stock - 2 WHERE product_id = 101;
UPDATE 1
postgres=*# -- If any of these fail, ALL are rolled back
postgres=*# COMMIT;
COMMIT
postgres=#
postgres=# SELECT * FROM orders;
 order_id | customer_id | order_date | total
----------+-------------+------------+--------
        1 |           1 | 2025-10-16 | 250.00
(1 row)


postgres=# SELECT * FROM order_items;
 item_id | order_id | product_id | quantity
---------+----------+------------+----------
       1 |        1 |        101 |        2
(1 row)


postgres=# SELECT * FROM inventory;
 product_id | product_name | stock
------------+--------------+-------
        102 | Mouse        |    50
        103 | Keyboard     |    25
        101 | Laptop       |     8
(3 rows)


postgres=#
postgres=#
postgres=# CREATE TABLE customers (
postgres(#     customer_id SERIAL PRIMARY KEY,
postgres(#     name VARCHAR(100),
postgres(#     email VARCHAR(100)
postgres(# );
CREATE TABLE
postgres=#
postgres=#
postgres=# BEGIN;
BEGIN
postgres=*# INSERT INTO customers (name, email) VALUES ('John Doe', 'john@email.com');
INSERT 0 1
postgres=*# INSERT INTO orders (customer_id, total) VALUES (LASTVAL(), 100.00);
INSERT 0 1
postgres=*# COMMIT;
COMMIT
postgres=#
postgres=#
postgres=# BEGIN TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
BEGIN
postgres=*# SELECT * FROM accounts; -- May see uncommitted changes
 account_id | owner_name | balance
------------+------------+---------
          1 | Aibek      |  400.00
          2 | Nursultan  | 1100.00
(2 rows)


postgres=*# COMMIT;
COMMIT
postgres=#
postgres=# BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
BEGIN
postgres=*# SELECT * FROM accounts WHERE balance > 1000;
 account_id | owner_name | balance
------------+------------+---------
          2 | Nursultan  | 1100.00
(1 row)


postgres=*# -- Another transaction might modify data here
postgres=*# SELECT * FROM accounts WHERE balance > 1000; -- May return different results
 account_id | owner_name | balance
------------+------------+---------
          2 | Nursultan  | 1100.00
(1 row)


postgres=*# COMMIT;
COMMIT
postgres=#
postgres=# BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN
postgres=*# SELECT * FROM accounts WHERE balance > 1000;
 account_id | owner_name | balance
------------+------------+---------
          2 | Nursultan  | 1100.00
(1 row)


postgres=*# -- Even if other transactions modify data, this query will return same results
postgres=*# SELECT * FROM accounts WHERE balance > 1000;
 account_id | owner_name | balance
------------+------------+---------
          2 | Nursultan  | 1100.00
(1 row)


postgres=*# COMMIT;
COMMIT
postgres=#
postgres=# BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN
postgres=*# SELECT * FROM accounts;
 account_id | owner_name | balance
------------+------------+---------
          1 | Aibek      |  400.00
          2 | Nursultan  | 1100.00
(2 rows)


postgres=*# UPDATE accounts SET balance = balance * 1.05; -- 5% interest
UPDATE 2
postgres=*# COMMIT;
COMMIT
postgres=#
postgres=# SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
ПРЕДУПРЕЖДЕНИЕ:  SET TRANSACTION может выполняться только внутри блоков транзакций
SET
postgres=#
postgres=#
postgres=# BEGIN;
BEGIN
postgres=*#
postgres=*# INSERT INTO customers (name, email) VALUES ('Alice', 'alice@email.com');
INSERT 0 1
postgres=*#
postgres=*# SAVEPOINT after_customer_insert;
SAVEPOINT
postgres=*#
postgres=*# INSERT INTO orders (customer_id, total) VALUES (1, 500.00);
INSERT 0 1
postgres=*#
postgres=*# -- Something went wrong with the order, rollback to savepoint
postgres=*# ROLLBACK TO SAVEPOINT after_customer_insert;
ROLLBACK
postgres=*#
postgres=*# -- Customer insert is still there, but order insert is undone
postgres=*# INSERT INTO orders (customer_id, total) VALUES (1, 300.00);
INSERT 0 1
postgres=*#
postgres=*# COMMIT; -- Only customer and the second order are committed
COMMIT
postgres=#
postgres=#
postgres=# BEGIN;
BEGIN
postgres=*#
postgres=#
postgres=#
postgres=# CREATE TABLE products (
postgres(#     product_id SERIAL PRIMARY KEY,
postgres(#     name VARCHAR(100) NOT NULL,
postgres(#     price DECIMAL(10,2) CHECK (price >= 0)
postgres(# );
CREATE TABLE
postgres=#
postgres=#
postgres=# BEGIN;
BEGIN
postgres=*#
postgres=*# INSERT INTO products (name, price) VALUES ('Laptop', 999.99);
INSERT 0 1
postgres=*# SAVEPOINT sp1;
SAVEPOINT
postgres=*#
postgres=*# INSERT INTO products (name, price) VALUES ('Mouse', 25.99);
INSERT 0 1
postgres=*# SAVEPOINT sp2;
SAVEPOINT
postgres=*#
postgres=*# INSERT INTO products (name, price) VALUES ('Invalid Product', -50.00);
ОШИБКА:  новая строка в отношении "products" нарушает ограничение-проверку "products_price_check"
DETAIL:  Ошибочная строка содержит (17, Invalid Product, -50.00).
postgres=!# -- This violates business rules
postgres=!#
postgres=!# ROLLBACK TO SAVEPOINT sp2; -- Removes invalid product insert
ROLLBACK
postgres=*# -- Laptop and Mouse inserts are still active
postgres=*#
postgres=*# INSERT INTO products (name, price) VALUES ('Keyboard', 79.99);
INSERT 0 1
postgres=*#
postgres=*# COMMIT; -- Commits Laptop, Mouse, and Keyboard
COMMIT
postgres=#
postgres=# CREATE TABLE logs (
postgres(#     log_id SERIAL PRIMARY KEY,
postgres(#     message TEXT NOT NULL,
postgres(#     log_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
postgres(# );
CREATE TABLE
postgres=#
postgres=# BEGIN;
BEGIN
postgres=*# INSERT INTO logs (message) VALUES ('Starting process');
INSERT 0 1
postgres=*# SAVEPOINT process_start;
SAVEPOINT
postgres=*#
postgres=*# -- Do some work
postgres=*# INSERT INTO logs (message) VALUES ('Process completed');
INSERT 0 1
postgres=*#
postgres=*# -- If everything is OK, release the savepoint
postgres=*# RELEASE SAVEPOINT process_start;
RELEASE
postgres=*#
postgres=*# COMMIT;
COMMIT
postgres=#
postgres=# BEGIN;
BEGIN
postgres=*# UPDATE inventory SET stock = stock - 1 WHERE product_id = 101;
UPDATE 1
postgres=*# INSERT INTO order_items (order_id, product_id, quantity) VALUES (1, 101, 1);
INSERT 0 1
postgres=*# COMMIT;
COMMIT
postgres=#
postgres=#
postgres=#
postgres=# BEGIN;
BEGIN
postgres=*# DO $$
postgres$*# DECLARE
postgres$*#     insufficient_funds EXCEPTION;
postgres$*#     current_balance DECIMAL;
postgres$*# BEGIN
postgres$*#     SELECT balance INTO current_balance FROM accounts WHERE account_id = 1;
postgres$*#
postgres$*#     IF current_balance < 100 THEN
postgres$*#         RAISE insufficient_funds;
postgres$*#     END IF;
postgres$*#
postgres$*#     UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
postgres$*#     UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;
postgres$*#
postgres$*# EXCEPTION
postgres$*#     WHEN insufficient_funds THEN
postgres$*#         RAISE NOTICE 'Transaction failed: Insufficient funds';
postgres$*#         ROLLBACK;
postgres$*# END $$;
ОШИБКА:  тип "exception" не существует
LINE 3:     insufficient_funds EXCEPTION;
                               ^
postgres=!#
postgres=!#
postgres=!#
postgres=!# BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
ОШИБКА:  текущая транзакция прервана, команды до конца блока транзакции игнорируются
postgres=!# -- Critical financial operations here
postgres=!# COMMIT;
ROLLBACK
postgres=# ROLLBACK;
ПРЕДУПРЕЖДЕНИЕ:  нет незавершённой транзакции
ROLLBACK
postgres=# BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN
postgres=*#
postgres=*# -- Здесь выполняются критические финансовые операции
postgres=*#
postgres=*# COMMIT;
COMMIT
postgres=# BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
BEGIN
postgres=*# -- Generate reports here
postgres=*# COMMIT;
COMMIT
postgres=#
postgres=# BEGIN;
BEGIN
postgres=*#
postgres=*# -- Main operation
postgres=*# INSERT INTO orders (customer_id, total) VALUES (1, 1000.00);
INSERT 0 1
postgres=*#
postgres=*# SAVEPOINT before_items;
SAVEPOINT
postgres=*#
postgres=*# -- Add items (might fail for some items)
postgres=*# INSERT INTO order_items (order_id, product_id, quantity)
postgres-*# VALUES (currval('orders_id_seq'), 101, 2);
ОШИБКА:  отношение "orders_id_seq" не существует
LINE 2: VALUES (currval('orders_id_seq'), 101, 2);
                        ^
postgres=!#
postgres=!# -- If this fails, rollback to savepoint and continue
postgres=!# INSERT INTO order_items (order_id, product_id, quantity)
postgres-!# VALUES (currval('orders_id_seq'), 102, 1);
ОШИБКА:  текущая транзакция прервана, команды до конца блока транзакции игнорируются
postgres=!#
postgres=!# COMMIT;
ROLLBACK
postgres=#
postgres=# SELECT
postgres-#     blocked_locks.pid AS blocked_pid,
postgres-#     blocked_activity.usename AS blocked_user,
postgres-#     blocking_locks.pid AS blocking_pid,
postgres-#     blocking_activity.usename AS blocking_user,
postgres-#     blocked_activity.query AS blocked_statement
postgres-# FROM pg_catalog.pg_locks blocked_locks
postgres-# JOIN pg_catalog.pg_stat_activity blocked_activity
postgres-#     ON blocked_activity.pid = blocked_locks.pid
postgres-# JOIN pg_catalog.pg_locks blocking_locks
postgres-#     ON blocking_locks.locktype = blocked_locks.locktype
postgres-#     AND blocking_locks.GRANTED
postgres-#     AND blocking_locks.pid != blocked_locks.pid
postgres-# JOIN pg_catalog.pg_stat_activity blocking_activity
postgres-#     ON blocking_activity.pid = blocking_locks.pid
postgres-# WHERE NOT blocked_locks.granted;
 blocked_pid | blocked_user | blocking_pid | blocking_user | blocked_statement
-------------+--------------+--------------+---------------+-------------------
(0 rows)


postgres=#
postgres=#
postgres=#
postgres=# CREATE TABLE audit_log (
postgres(#     log_id SERIAL PRIMARY KEY,
postgres(#     action TEXT NOT NULL,
postgres(#     log_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
postgres(# );
CREATE TABLE
postgres=#
postgres=# CREATE TABLE users (
postgres(#     user_id SERIAL PRIMARY KEY,
postgres(#     name VARCHAR(100),
postgres(#     email VARCHAR(100)
postgres(# );
CREATE TABLE
postgres=#
postgres=# CREATE TABLE user_preferences (
postgres(#     pref_id SERIAL PRIMARY KEY,
postgres(#     user_id INT REFERENCES users(user_id),
postgres(#     theme VARCHAR(50)
postgres(# );
CREATE TABLE
postgres=#
postgres=#
postgres=# BEGIN;
BEGIN
postgres=#
postgres=#
postgres=# BEGIN;
BEGIN
postgres=*#
postgres=*# INSERT INTO audit_log (action) VALUES ('user_creation');
INSERT 0 1
postgres=*#
postgres=*# INSERT INTO users (name, email)
postgres-*# VALUES ('John Doe', 'john@example.com')
postgres-*# RETURNING user_id;
 user_id
---------
       1
(1 row)


INSERT 0 1
postgres=*#
postgres=*#
postgres=*# INSERT INTO user_preferences (user_id, theme)
postgres-*# VALUES (1, 'dark');
INSERT 0 1
postgres=*#
postgres=*# COMMIT;
COMMIT
postgres=#
postgres=# -- If this fails, the audit log entry above is already committed
postgres=# INSERT INTO users (name, email) VALUES ('John Doe', 'john@example.com');
INSERT 0 1
postgres=#
postgres=#
postgres=# INSERT INTO audit_log (action, log_time) VALUES ('user_creation', NOW());
INSERT 0 1
postgres=#
postgres=#
postgres=# INSERT INTO users (name, email) VALUES ('John Doe', 'john@example.com');
INSERT 0 1
postgres=#
postgres=#